// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "fight.proto" (package "fight", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// ---------- FIGHT MESSAGES ----------

// *// Messages sent by the server to the client during a fight to signify events in the fight.// Should include:// - Unit actions (attack, spells, skills...) and their result (success, miss, target)// - End of fight// 

/**
 * @generated from protobuf message fight.RequestFightNextTickMessage
 */
export interface RequestFightNextTickMessage {
    /**
     * @generated from protobuf field: uint32 fight_id = 1;
     */
    fightId: number;
}
// // enum ResponseFightNextTickErrors {// None,// }

/**
 * @generated from protobuf message fight.ResponseFightNextTick
 */
export interface ResponseFightNextTick {
}
/**
 * @generated from protobuf message fight.ClientFightMessage
 */
export interface ClientFightMessage {
    /**
     * @generated from protobuf oneof: client_message
     */
    clientMessage: {
        oneofKind: "requestStartFight";
        /**
         * @generated from protobuf field: fight.RequestStartFight request_start_fight = 1;
         */
        requestStartFight: RequestStartFight;
    } | {
        oneofKind: "requestNextTick";
        /**
         * @generated from protobuf field: fight.RequestNextTick request_next_tick = 2;
         */
        requestNextTick: RequestNextTick;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message fight.RequestStartFight
 */
export interface RequestStartFight {
    /**
     * @generated from protobuf field: string player_id = 1;
     */
    playerId: string;
}
/**
 * @generated from protobuf message fight.RequestNextTick
 */
export interface RequestNextTick {
}
/**
 * @generated from protobuf message fight.ServerFightMessage
 */
export interface ServerFightMessage {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "startFight";
        /**
         * @generated from protobuf field: fight.StartFight start_fight = 1;
         */
        startFight: StartFight;
    } | {
        oneofKind: "fightAction";
        /**
         * @generated from protobuf field: fight.FightAction fight_action = 2;
         */
        fightAction: FightAction;
    } | {
        oneofKind: "endFight";
        /**
         * @generated from protobuf field: fight.EndFight end_fight = 3;
         */
        endFight: EndFight;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message fight.UnitReference
 */
export interface UnitReference {
    /**
     * @generated from protobuf field: bool is_player = 1;
     */
    isPlayer: boolean;
    /**
     * @generated from protobuf field: uint32 unit_id = 2;
     */
    unitId: number;
}
/**
 * @generated from protobuf message fight.ActionResultMiss
 */
export interface ActionResultMiss {
}
/**
 * @generated from protobuf message fight.ActionResultDamage
 */
export interface ActionResultDamage {
    /**
     * @generated from protobuf field: uint32 value = 1;
     */
    value: number;
    /**
     * @generated from protobuf field: bool unit_dies = 2;
     */
    unitDies: boolean;
}
/**
 * @generated from protobuf message fight.ActionResultHeal
 */
export interface ActionResultHeal {
    /**
     * @generated from protobuf field: uint32 value = 1;
     */
    value: number;
}
/**
 * @generated from protobuf message fight.ActionResult
 */
export interface ActionResult {
    /**
     * @generated from protobuf field: fight.UnitReference target = 1;
     */
    target?: UnitReference;
    /**
     * @generated from protobuf oneof: action_result_payload
     */
    actionResultPayload: {
        oneofKind: "actionResultMiss";
        /**
         * @generated from protobuf field: fight.ActionResultMiss action_result_miss = 2;
         */
        actionResultMiss: ActionResultMiss;
    } | {
        oneofKind: "actionResultDamage";
        /**
         * @generated from protobuf field: fight.ActionResultDamage action_result_damage = 3;
         */
        actionResultDamage: ActionResultDamage;
    } | {
        oneofKind: "actionResultHeal";
        /**
         * @generated from protobuf field: fight.ActionResultHeal action_result_heal = 4;
         */
        actionResultHeal: ActionResultHeal;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message fight.FightActionAttack
 */
export interface FightActionAttack {
}
/**
 * @generated from protobuf message fight.FightSkillAction
 */
export interface FightSkillAction {
    /**
     * @generated from protobuf field: uint32 skill_id = 1;
     */
    skillId: number;
}
/**
 * @generated from protobuf message fight.FightSpellAction
 */
export interface FightSpellAction {
    /**
     * @generated from protobuf field: uint32 spell_id = 1;
     */
    spellId: number;
}
/**
 * @generated from protobuf message fight.FightAction
 */
export interface FightAction {
    /**
     * @generated from protobuf field: fight.UnitReference unit_id = 1;
     */
    unitId?: UnitReference;
    /**
     * @generated from protobuf oneof: action
     */
    action: {
        oneofKind: "fightActionAttack";
        /**
         * @generated from protobuf field: fight.FightActionAttack fight_action_attack = 2;
         */
        fightActionAttack: FightActionAttack;
    } | {
        oneofKind: "fightActionSkill";
        /**
         * @generated from protobuf field: fight.FightSkillAction fight_action_skill = 3;
         */
        fightActionSkill: FightSkillAction;
    } | {
        oneofKind: "fightActionSpell";
        /**
         * @generated from protobuf field: fight.FightSpellAction fight_action_spell = 4;
         */
        fightActionSpell: FightSpellAction;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: repeated fight.ActionResult action_result = 5;
     */
    actionResult: ActionResult[];
}
// // message FightReward {// uint32 experience = 0;// }

/**
 * @generated from protobuf message fight.EndFight
 */
export interface EndFight {
    /**
     * @generated from protobuf field: bool is_player_victory = 1;
     */
    isPlayerVictory: boolean;
    /**
     * @generated from protobuf field: uint32 experience = 2;
     */
    experience: number;
}
/**
 * @generated from protobuf message fight.RawCharacterData
 */
export interface RawCharacterData {
    /**
     * @generated from protobuf field: uint32 max_hp = 1;
     */
    maxHp: number;
    /**
     * @generated from protobuf field: uint32 attack = 2;
     */
    attack: number;
    /**
     * @generated from protobuf field: uint32 defense = 3;
     */
    defense: number;
    /**
     * @generated from protobuf field: uint32 speed = 4;
     */
    speed: number; // uint32 experience = 3;}
/**
 * @generated from protobuf message fight.StartFight
 */
export interface StartFight {
    /**
     * @generated from protobuf field: uint32 fight_id = 1;
     */
    fightId: number;
    /**
     * @generated from protobuf field: repeated fight.RawCharacterData player_characters = 2;
     */
    playerCharacters: RawCharacterData[];
    /**
     * @generated from protobuf field: repeated fight.RawCharacterData enemy_characters = 3;
     */
    enemyCharacters: RawCharacterData[];
}
// @generated message type with reflection information, may provide speed optimized methods
class RequestFightNextTickMessage$Type extends MessageType<RequestFightNextTickMessage> {
    constructor() {
        super("fight.RequestFightNextTickMessage", [
            { no: 1, name: "fight_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RequestFightNextTickMessage>): RequestFightNextTickMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fightId = 0;
        if (value !== undefined)
            reflectionMergePartial<RequestFightNextTickMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestFightNextTickMessage): RequestFightNextTickMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 fight_id */ 1:
                    message.fightId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestFightNextTickMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 fight_id = 1; */
        if (message.fightId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.fightId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.RequestFightNextTickMessage
 */
export const RequestFightNextTickMessage = new RequestFightNextTickMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseFightNextTick$Type extends MessageType<ResponseFightNextTick> {
    constructor() {
        super("fight.ResponseFightNextTick", []);
    }
    create(value?: PartialMessage<ResponseFightNextTick>): ResponseFightNextTick {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResponseFightNextTick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseFightNextTick): ResponseFightNextTick {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResponseFightNextTick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.ResponseFightNextTick
 */
export const ResponseFightNextTick = new ResponseFightNextTick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientFightMessage$Type extends MessageType<ClientFightMessage> {
    constructor() {
        super("fight.ClientFightMessage", [
            { no: 1, name: "request_start_fight", kind: "message", oneof: "clientMessage", T: () => RequestStartFight },
            { no: 2, name: "request_next_tick", kind: "message", oneof: "clientMessage", T: () => RequestNextTick }
        ]);
    }
    create(value?: PartialMessage<ClientFightMessage>): ClientFightMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clientMessage = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ClientFightMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientFightMessage): ClientFightMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fight.RequestStartFight request_start_fight */ 1:
                    message.clientMessage = {
                        oneofKind: "requestStartFight",
                        requestStartFight: RequestStartFight.internalBinaryRead(reader, reader.uint32(), options, (message.clientMessage as any).requestStartFight)
                    };
                    break;
                case /* fight.RequestNextTick request_next_tick */ 2:
                    message.clientMessage = {
                        oneofKind: "requestNextTick",
                        requestNextTick: RequestNextTick.internalBinaryRead(reader, reader.uint32(), options, (message.clientMessage as any).requestNextTick)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientFightMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fight.RequestStartFight request_start_fight = 1; */
        if (message.clientMessage.oneofKind === "requestStartFight")
            RequestStartFight.internalBinaryWrite(message.clientMessage.requestStartFight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* fight.RequestNextTick request_next_tick = 2; */
        if (message.clientMessage.oneofKind === "requestNextTick")
            RequestNextTick.internalBinaryWrite(message.clientMessage.requestNextTick, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.ClientFightMessage
 */
export const ClientFightMessage = new ClientFightMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestStartFight$Type extends MessageType<RequestStartFight> {
    constructor() {
        super("fight.RequestStartFight", [
            { no: 1, name: "player_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestStartFight>): RequestStartFight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playerId = "";
        if (value !== undefined)
            reflectionMergePartial<RequestStartFight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestStartFight): RequestStartFight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string player_id */ 1:
                    message.playerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestStartFight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string player_id = 1; */
        if (message.playerId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.RequestStartFight
 */
export const RequestStartFight = new RequestStartFight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestNextTick$Type extends MessageType<RequestNextTick> {
    constructor() {
        super("fight.RequestNextTick", []);
    }
    create(value?: PartialMessage<RequestNextTick>): RequestNextTick {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<RequestNextTick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestNextTick): RequestNextTick {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RequestNextTick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.RequestNextTick
 */
export const RequestNextTick = new RequestNextTick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServerFightMessage$Type extends MessageType<ServerFightMessage> {
    constructor() {
        super("fight.ServerFightMessage", [
            { no: 1, name: "start_fight", kind: "message", oneof: "payload", T: () => StartFight },
            { no: 2, name: "fight_action", kind: "message", oneof: "payload", T: () => FightAction },
            { no: 3, name: "end_fight", kind: "message", oneof: "payload", T: () => EndFight }
        ]);
    }
    create(value?: PartialMessage<ServerFightMessage>): ServerFightMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ServerFightMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ServerFightMessage): ServerFightMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fight.StartFight start_fight */ 1:
                    message.payload = {
                        oneofKind: "startFight",
                        startFight: StartFight.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).startFight)
                    };
                    break;
                case /* fight.FightAction fight_action */ 2:
                    message.payload = {
                        oneofKind: "fightAction",
                        fightAction: FightAction.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).fightAction)
                    };
                    break;
                case /* fight.EndFight end_fight */ 3:
                    message.payload = {
                        oneofKind: "endFight",
                        endFight: EndFight.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).endFight)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ServerFightMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fight.StartFight start_fight = 1; */
        if (message.payload.oneofKind === "startFight")
            StartFight.internalBinaryWrite(message.payload.startFight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* fight.FightAction fight_action = 2; */
        if (message.payload.oneofKind === "fightAction")
            FightAction.internalBinaryWrite(message.payload.fightAction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* fight.EndFight end_fight = 3; */
        if (message.payload.oneofKind === "endFight")
            EndFight.internalBinaryWrite(message.payload.endFight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.ServerFightMessage
 */
export const ServerFightMessage = new ServerFightMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnitReference$Type extends MessageType<UnitReference> {
    constructor() {
        super("fight.UnitReference", [
            { no: 1, name: "is_player", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "unit_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnitReference>): UnitReference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isPlayer = false;
        message.unitId = 0;
        if (value !== undefined)
            reflectionMergePartial<UnitReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnitReference): UnitReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_player */ 1:
                    message.isPlayer = reader.bool();
                    break;
                case /* uint32 unit_id */ 2:
                    message.unitId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnitReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_player = 1; */
        if (message.isPlayer !== false)
            writer.tag(1, WireType.Varint).bool(message.isPlayer);
        /* uint32 unit_id = 2; */
        if (message.unitId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.unitId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.UnitReference
 */
export const UnitReference = new UnitReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionResultMiss$Type extends MessageType<ActionResultMiss> {
    constructor() {
        super("fight.ActionResultMiss", []);
    }
    create(value?: PartialMessage<ActionResultMiss>): ActionResultMiss {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ActionResultMiss>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionResultMiss): ActionResultMiss {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ActionResultMiss, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.ActionResultMiss
 */
export const ActionResultMiss = new ActionResultMiss$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionResultDamage$Type extends MessageType<ActionResultDamage> {
    constructor() {
        super("fight.ActionResultDamage", [
            { no: 1, name: "value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "unit_dies", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ActionResultDamage>): ActionResultDamage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        message.unitDies = false;
        if (value !== undefined)
            reflectionMergePartial<ActionResultDamage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionResultDamage): ActionResultDamage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 value */ 1:
                    message.value = reader.uint32();
                    break;
                case /* bool unit_dies */ 2:
                    message.unitDies = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionResultDamage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).uint32(message.value);
        /* bool unit_dies = 2; */
        if (message.unitDies !== false)
            writer.tag(2, WireType.Varint).bool(message.unitDies);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.ActionResultDamage
 */
export const ActionResultDamage = new ActionResultDamage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionResultHeal$Type extends MessageType<ActionResultHeal> {
    constructor() {
        super("fight.ActionResultHeal", [
            { no: 1, name: "value", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ActionResultHeal>): ActionResultHeal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = 0;
        if (value !== undefined)
            reflectionMergePartial<ActionResultHeal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionResultHeal): ActionResultHeal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 value */ 1:
                    message.value = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionResultHeal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 value = 1; */
        if (message.value !== 0)
            writer.tag(1, WireType.Varint).uint32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.ActionResultHeal
 */
export const ActionResultHeal = new ActionResultHeal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActionResult$Type extends MessageType<ActionResult> {
    constructor() {
        super("fight.ActionResult", [
            { no: 1, name: "target", kind: "message", T: () => UnitReference },
            { no: 2, name: "action_result_miss", kind: "message", oneof: "actionResultPayload", T: () => ActionResultMiss },
            { no: 3, name: "action_result_damage", kind: "message", oneof: "actionResultPayload", T: () => ActionResultDamage },
            { no: 4, name: "action_result_heal", kind: "message", oneof: "actionResultPayload", T: () => ActionResultHeal }
        ]);
    }
    create(value?: PartialMessage<ActionResult>): ActionResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actionResultPayload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ActionResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActionResult): ActionResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fight.UnitReference target */ 1:
                    message.target = UnitReference.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* fight.ActionResultMiss action_result_miss */ 2:
                    message.actionResultPayload = {
                        oneofKind: "actionResultMiss",
                        actionResultMiss: ActionResultMiss.internalBinaryRead(reader, reader.uint32(), options, (message.actionResultPayload as any).actionResultMiss)
                    };
                    break;
                case /* fight.ActionResultDamage action_result_damage */ 3:
                    message.actionResultPayload = {
                        oneofKind: "actionResultDamage",
                        actionResultDamage: ActionResultDamage.internalBinaryRead(reader, reader.uint32(), options, (message.actionResultPayload as any).actionResultDamage)
                    };
                    break;
                case /* fight.ActionResultHeal action_result_heal */ 4:
                    message.actionResultPayload = {
                        oneofKind: "actionResultHeal",
                        actionResultHeal: ActionResultHeal.internalBinaryRead(reader, reader.uint32(), options, (message.actionResultPayload as any).actionResultHeal)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActionResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fight.UnitReference target = 1; */
        if (message.target)
            UnitReference.internalBinaryWrite(message.target, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* fight.ActionResultMiss action_result_miss = 2; */
        if (message.actionResultPayload.oneofKind === "actionResultMiss")
            ActionResultMiss.internalBinaryWrite(message.actionResultPayload.actionResultMiss, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* fight.ActionResultDamage action_result_damage = 3; */
        if (message.actionResultPayload.oneofKind === "actionResultDamage")
            ActionResultDamage.internalBinaryWrite(message.actionResultPayload.actionResultDamage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* fight.ActionResultHeal action_result_heal = 4; */
        if (message.actionResultPayload.oneofKind === "actionResultHeal")
            ActionResultHeal.internalBinaryWrite(message.actionResultPayload.actionResultHeal, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.ActionResult
 */
export const ActionResult = new ActionResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightActionAttack$Type extends MessageType<FightActionAttack> {
    constructor() {
        super("fight.FightActionAttack", []);
    }
    create(value?: PartialMessage<FightActionAttack>): FightActionAttack {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FightActionAttack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightActionAttack): FightActionAttack {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FightActionAttack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.FightActionAttack
 */
export const FightActionAttack = new FightActionAttack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightSkillAction$Type extends MessageType<FightSkillAction> {
    constructor() {
        super("fight.FightSkillAction", [
            { no: 1, name: "skill_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FightSkillAction>): FightSkillAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.skillId = 0;
        if (value !== undefined)
            reflectionMergePartial<FightSkillAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightSkillAction): FightSkillAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 skill_id */ 1:
                    message.skillId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightSkillAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 skill_id = 1; */
        if (message.skillId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.skillId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.FightSkillAction
 */
export const FightSkillAction = new FightSkillAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightSpellAction$Type extends MessageType<FightSpellAction> {
    constructor() {
        super("fight.FightSpellAction", [
            { no: 1, name: "spell_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FightSpellAction>): FightSpellAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.spellId = 0;
        if (value !== undefined)
            reflectionMergePartial<FightSpellAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightSpellAction): FightSpellAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 spell_id */ 1:
                    message.spellId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightSpellAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 spell_id = 1; */
        if (message.spellId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.spellId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.FightSpellAction
 */
export const FightSpellAction = new FightSpellAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightAction$Type extends MessageType<FightAction> {
    constructor() {
        super("fight.FightAction", [
            { no: 1, name: "unit_id", kind: "message", T: () => UnitReference },
            { no: 2, name: "fight_action_attack", kind: "message", oneof: "action", T: () => FightActionAttack },
            { no: 3, name: "fight_action_skill", kind: "message", oneof: "action", T: () => FightSkillAction },
            { no: 4, name: "fight_action_spell", kind: "message", oneof: "action", T: () => FightSpellAction },
            { no: 5, name: "action_result", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ActionResult }
        ]);
    }
    create(value?: PartialMessage<FightAction>): FightAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = { oneofKind: undefined };
        message.actionResult = [];
        if (value !== undefined)
            reflectionMergePartial<FightAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightAction): FightAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fight.UnitReference unit_id */ 1:
                    message.unitId = UnitReference.internalBinaryRead(reader, reader.uint32(), options, message.unitId);
                    break;
                case /* fight.FightActionAttack fight_action_attack */ 2:
                    message.action = {
                        oneofKind: "fightActionAttack",
                        fightActionAttack: FightActionAttack.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).fightActionAttack)
                    };
                    break;
                case /* fight.FightSkillAction fight_action_skill */ 3:
                    message.action = {
                        oneofKind: "fightActionSkill",
                        fightActionSkill: FightSkillAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).fightActionSkill)
                    };
                    break;
                case /* fight.FightSpellAction fight_action_spell */ 4:
                    message.action = {
                        oneofKind: "fightActionSpell",
                        fightActionSpell: FightSpellAction.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).fightActionSpell)
                    };
                    break;
                case /* repeated fight.ActionResult action_result */ 5:
                    message.actionResult.push(ActionResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fight.UnitReference unit_id = 1; */
        if (message.unitId)
            UnitReference.internalBinaryWrite(message.unitId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* fight.FightActionAttack fight_action_attack = 2; */
        if (message.action.oneofKind === "fightActionAttack")
            FightActionAttack.internalBinaryWrite(message.action.fightActionAttack, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* fight.FightSkillAction fight_action_skill = 3; */
        if (message.action.oneofKind === "fightActionSkill")
            FightSkillAction.internalBinaryWrite(message.action.fightActionSkill, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* fight.FightSpellAction fight_action_spell = 4; */
        if (message.action.oneofKind === "fightActionSpell")
            FightSpellAction.internalBinaryWrite(message.action.fightActionSpell, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated fight.ActionResult action_result = 5; */
        for (let i = 0; i < message.actionResult.length; i++)
            ActionResult.internalBinaryWrite(message.actionResult[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.FightAction
 */
export const FightAction = new FightAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndFight$Type extends MessageType<EndFight> {
    constructor() {
        super("fight.EndFight", [
            { no: 1, name: "is_player_victory", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "experience", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EndFight>): EndFight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isPlayerVictory = false;
        message.experience = 0;
        if (value !== undefined)
            reflectionMergePartial<EndFight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndFight): EndFight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_player_victory */ 1:
                    message.isPlayerVictory = reader.bool();
                    break;
                case /* uint32 experience */ 2:
                    message.experience = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndFight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_player_victory = 1; */
        if (message.isPlayerVictory !== false)
            writer.tag(1, WireType.Varint).bool(message.isPlayerVictory);
        /* uint32 experience = 2; */
        if (message.experience !== 0)
            writer.tag(2, WireType.Varint).uint32(message.experience);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.EndFight
 */
export const EndFight = new EndFight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RawCharacterData$Type extends MessageType<RawCharacterData> {
    constructor() {
        super("fight.RawCharacterData", [
            { no: 1, name: "max_hp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "attack", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "defense", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "speed", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<RawCharacterData>): RawCharacterData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.maxHp = 0;
        message.attack = 0;
        message.defense = 0;
        message.speed = 0;
        if (value !== undefined)
            reflectionMergePartial<RawCharacterData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RawCharacterData): RawCharacterData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 max_hp */ 1:
                    message.maxHp = reader.uint32();
                    break;
                case /* uint32 attack */ 2:
                    message.attack = reader.uint32();
                    break;
                case /* uint32 defense */ 3:
                    message.defense = reader.uint32();
                    break;
                case /* uint32 speed */ 4:
                    message.speed = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RawCharacterData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 max_hp = 1; */
        if (message.maxHp !== 0)
            writer.tag(1, WireType.Varint).uint32(message.maxHp);
        /* uint32 attack = 2; */
        if (message.attack !== 0)
            writer.tag(2, WireType.Varint).uint32(message.attack);
        /* uint32 defense = 3; */
        if (message.defense !== 0)
            writer.tag(3, WireType.Varint).uint32(message.defense);
        /* uint32 speed = 4; */
        if (message.speed !== 0)
            writer.tag(4, WireType.Varint).uint32(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.RawCharacterData
 */
export const RawCharacterData = new RawCharacterData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartFight$Type extends MessageType<StartFight> {
    constructor() {
        super("fight.StartFight", [
            { no: 1, name: "fight_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "player_characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RawCharacterData },
            { no: 3, name: "enemy_characters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RawCharacterData }
        ]);
    }
    create(value?: PartialMessage<StartFight>): StartFight {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fightId = 0;
        message.playerCharacters = [];
        message.enemyCharacters = [];
        if (value !== undefined)
            reflectionMergePartial<StartFight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartFight): StartFight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 fight_id */ 1:
                    message.fightId = reader.uint32();
                    break;
                case /* repeated fight.RawCharacterData player_characters */ 2:
                    message.playerCharacters.push(RawCharacterData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated fight.RawCharacterData enemy_characters */ 3:
                    message.enemyCharacters.push(RawCharacterData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartFight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 fight_id = 1; */
        if (message.fightId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.fightId);
        /* repeated fight.RawCharacterData player_characters = 2; */
        for (let i = 0; i < message.playerCharacters.length; i++)
            RawCharacterData.internalBinaryWrite(message.playerCharacters[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated fight.RawCharacterData enemy_characters = 3; */
        for (let i = 0; i < message.enemyCharacters.length; i++)
            RawCharacterData.internalBinaryWrite(message.enemyCharacters[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message fight.StartFight
 */
export const StartFight = new StartFight$Type();
/**
 * @generated ServiceType for protobuf service fight.FightService
 */
export const FightService = new ServiceType("fight.FightService", [
    { name: "Fight", serverStreaming: true, clientStreaming: true, options: {}, I: ClientFightMessage, O: ServerFightMessage },
    { name: "RequestFightStart", serverStreaming: true, options: {}, I: RequestStartFight, O: ServerFightMessage },
    { name: "RequestFightNextTick", options: {}, I: RequestFightNextTickMessage, O: ResponseFightNextTick }
]);
